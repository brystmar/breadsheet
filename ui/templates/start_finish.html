<div class="container" id="start_finish_div">
    <table id="start_finish" class="table table-condensed">
        <tr id="summary_start_row">
            <th>Start:</th>
            <td>
                <!-- <div id="start_time_text">{{ recipe.start_time_ui }}</div> -->
                <div id="start_time_controls">
                    {{ seform.start_date }} &nbsp; {{ seform.start_time }}
                    <button onclick="setNow('start')" id="start_now" class="btn btn-default" disabled>Start Now</button>
                </div>
            </td>

        </tr>
        <tr id="summary_finish_row">
            <th>Finish:</th>
            <td>
                <!-- <div id="finish_time_text">{{ recipe.finish_time_ui }}</div> -->
                <div id="finish_time_controls">
                    {{ seform.finish_date }} &nbsp; {{ seform.finish_time }}
                    <button onclick="setNow('finish')" id="finish_now" class="btn btn-default">Finish Now</button>
                </div>
            </td>
        </tr>
        <tr>
            <th>{{ seform.solve_for_start.label }}:</th>
            <td>
                {{ seform.solve_for_start(size=2) }}
                <button id="calculate" onclick="calcTime()" class="btn btn-success">Calculate</button>
            </td>
        </tr>
    </table>
</div>

<script onload="sfToggle()">
    // add an event listener for the selection box
    document.getElementById("solve_for_start").addEventListener("change", sfToggle);

    function sfToggle() {
        var box = document.getElementById("solve_for_start");
        var sdate = document.getElementById("start_date");
        var stime = document.getElementById("start_time");
        var fdate = document.getElementById("finish_date");
        var ftime = document.getElementById("finish_time");
        var s_now = document.getElementById("start_now");
        var f_now = document.getElementById("finish_now");

        if (box.value == "1") {
            sdate.disabled = true;
            stime.disabled = true;
            s_now.disabled = true;
            fdate.disabled = false;
            ftime.disabled = false;
            f_now.disabled = false;
        }
        else {
            sdate.disabled = false;
            stime.disabled = false;
            s_now.disabled = false;
            fdate.disabled = true;
            ftime.disabled = true;
            f_now.disabled = true;
        }
    }

    function setNow(obj_prefix) {
        document.getElementById(obj_prefix + '_date').value = moment().format('YYYY-MM-DD');
        document.getElementById(obj_prefix + '_time').value = moment().format('HH:mm');
    }

    function calcTime() {
        var solve_for_start = document.getElementById("solve_for_start");
        var sdate = document.getElementById("start_date");
        var stime = document.getElementById("start_time");
        var fdate = document.getElementById("finish_date");
        var ftime = document.getElementById("finish_time");
        var ttime = document.getElementById("recipe_total_time");

        var start = moment(sdate.value + " " + stime.value);
        var start_orig = moment(sdate.value + " " + stime.value);
        var finish = moment(fdate.value + " " + ftime.value);
        var finish_orig = moment(fdate.value + " " + ftime.value);

        // collect all the 'then_wait' inputs from the steps_list table
        var table = document.getElementById("steps_list");
        var input_tags = table.getElementsByTagName("input");

        var step_number = 0;
        var seconds = 0;
        var total = 0;

        // initialize an array of steps
        var step_list = [];
        // initialize a dictionary of key-values for wait times
        var step_wait_times = {};

        for (var i=0; i < input_tags.length; i++) {
            // convert text values to seconds
            if (input_tags[i].id.indexOf("then_wait_h") == 0) {
                // make sure we're looking at the then_wait_h tag
                seconds = Number(input_tags[i].value) * 60 * 60;
            }
            else if (input_tags[i].id.indexOf("then_wait_m") == 0) {
                // make sure we're looking at the then_wait_m tag
                seconds = Number(input_tags[i].value) * 60;
            }
            else {
                seconds = 0;
            }

            total += seconds;

            // extract the step_number by taking a substring starting after the 11th character.  Ex: then_wait_h13
            step_number = Number(input_tags[i].id.substring(11));

            // only use use += if this step_id is already in the dictionary
            if (step_wait_times.hasOwnProperty(step_number)) {
                // the hours value (in seconds) for this step is already here, so add the minutes value (in seconds)
                step_wait_times[step_number] += seconds;
            }
            else {
                // add this step to the dictionary
                step_wait_times[step_number] = seconds;
            }
        }

        // compile a list of the step_numbers
        for (var key in step_wait_times) {
            step_list.push(key);
        }

        // update start & finish times
        if (solve_for_start.value == 0) {  // user entered their desired start time; app solves for finish
            finish = start.add(total, 'seconds');
            fdate.value = finish.format('YYYY-MM-DD');
            ftime.value = finish.format('HH:mm');
        }
        else {  // user entered their desired finish time; app solves for start
            start = finish.add(-total, 'seconds');
            sdate.value = start.format('YYYY-MM-DD');
            stime.value = start.format('HH:mm');
        }

        // update the total time
        ttime.innerHTML = sec_to_hms(total);

        var next_time = 0;
        var multiplier = 1;

        // sort the steps array
        if (solve_for_start.value == 0) {  // ascending if we're solving for finish time
            step_list.sort(sortNumberAsc);  // the built-in sort function returns: 1,10,11,12,13,2,3,4,5,6,7,8,9
            next_time = start_orig;
            multiplier = 1;
        }
        else {  // descending if we're solving for start time
            step_list.sort(sortNumberDesc);
            // step_list.reverse();
            next_time = finish_orig;  // work backwards from the user-defined finish time
            multiplier = -1;  // subtract time since we're working backwards
        }

        // update the 'when' labels in the steps list
        for (i=0; i < step_list.length; i++) {
            var when_label = document.getElementById("step_when" + step_list[i]);
            // out1.innerHTML += solve_for_start.value + ", i=" + i + ", steps[i]=" + steps[i] + " -- ";
            // out1.innerHTML += step_wait_times[steps[i]] + ".	time: " + next_time.format('YYYY-MM-DD HH:mm') + "<br>"

            if (solve_for_start.value == 0) {
                // when solving for finish, update the label before incrementing next_time
                when_label.innerHTML = next_time.format('ddd HH:mm');
                next_time = next_time.add(step_wait_times[step_list[i]] * multiplier, 'seconds');
            }
            else {
                // when solving for the start time, increment the next_time value before updating the label
                next_time = next_time.add(step_wait_times[step_list[i]] * multiplier, 'seconds');
                when_label.innerHTML = next_time.format('ddd HH:mm');
            }
        }
    }

    function sec_to_hms(sec) {
        // accepts a number of seconds (int), returns a string for how many days, hrs, min, sec
        if (sec == 0) { return "--"; }

        var result = "";
        var days = "";
        var hours = "";
        var minutes = "";

        var d = Math.floor(sec / 86400);
        if (d > 0) {
            // select the right verbiage for day(s)
            if (d > 1) {
                days = d.toString() + " days";
            }
            else {
                days = d.toString() + " day";
            }

            // set the result value
            result = days;

            // remove a rounded-day number of seconds from the sec variable
            sec -= (d * 86400)
        }

        var h = Math.floor(sec / 3600);
        if (h > 0) {
            // select the right verbiage for hour(s)
            if (h > 1) {
                hours = h.toString() + " hrs";
            }
            else {
                hours = h.toString() + " hr";
            }

            // if there's already data in the result variable, tack on a comma and append the hours
            if (result != "") {
                result += ", " + hours;
            }
            else {
                result = hours;
            }

            // remove a rounded-hour number of seconds from the sec variable
            sec -= (h * 3600)
        }

        var m = Math.floor(sec / 60) % 60;
        if (m > 0) {
            minutes = m.toString() + " min";

            // if there's already data in the result variable, tack on a comma and append the minutes
            if (result != "") {
                result += ", " + minutes;
            }
            else {
                result = minutes;
            }
        }

        return result;
    }

    function sortNumberAsc(a, b) {
        // A proper sorting function because JavaScript is dumb
        // The built-in sort function would return: 1,10,11,12,13,2,3,4,5,6,7,8,9
        return a - b;
    }

    function sortNumberDesc(a, b) {
        // The built-in sort function would return: 9,8,7,6,5,4,3,2,13,12,11,10,1
        return b - a;
    }
</script>
